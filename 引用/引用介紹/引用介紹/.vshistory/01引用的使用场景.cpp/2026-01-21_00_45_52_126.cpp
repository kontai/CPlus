#define _CRT_SECURE_NO_WARNINGS
#include<iostream>

using namespace std;

/*
*2026/01/21
*AUTHOR:kontai
*
*本文件演示C++中引用(Reference)的三個主要使用場景：
*1. 引用作為函數參數 - 實現按引用傳遞
*2. 引用作為函數返回值 - 返回對象的引用
*3. 靜態變數引用 - 確保返回的引用有效生命周期
*/

//=============================================================================
// 場景1：引用作為函數參數傳遞
//=============================================================================

/// <summary>
/// 計算兩個整數的和
/// 通過引用參數傳遞，避免複製，提高效率
/// </summary>
/// <param name="a">第一個整數的引用</param>
/// <param name="b">第二個整數的引用</param>
void fun(int& a, int &b) {
	int sum = a + b;
	cout << "sum=" << sum << endl;
}

/// <summary>
/// 測試場景1：引用作為函數參數
/// </summary>
void test01() {
	int a = 10;
	int b = 20;
	fun(a, b);	// 輸出：sum=30
}

//=============================================================================
// 場景2：引用作為函數返回值
//=============================================================================

/// <summary>
/// 返回本地變數的引用（危險做法）
/// 警告：不應該返回指向局部變數的引用，因為局部變數在函數返回後被銷毀
/// 這會導致懸空引用(dangling reference)
/// </summary>
/// <returns>指向已銷毀局部變數的引用（未定義行為）</returns>
int& fun2() {
	int b = 20;
	int& ref = b;		// ref 引用局部變數 b
	return ref;			// 危險：返回指向局部變數的引用
}

/// <summary>
/// 返回靜態變數的引用（安全做法）
/// 靜態變數在程式整個生命周期內存在，所以返回其引用是安全的
/// </summary>
/// <returns>指向靜態變數的引用</returns>
int& fun3(){
	static int b = 20;	// 靜態變數，只初始化一次，整個程式生命周期內存在
	int& ref = b;		// ref 引用靜態變數 b
	return ref;			// 安全：返回指向靜態變數的引用
}

/// <summary>
/// 測試場景2：引用作為函數返回值
/// 演示危險的懸空引用和安全的靜態變數引用
/// </summary>
void test02() {
	// fun2() 的使用已註釋掉，因為它會導致未定義行為
	// int &c = fun2();
	// c = 20;
	// cout << "c=" << c << endl;

	// 安全的做法：使用返回靜態變數引用的函數
	int& d = fun3();		// d 引用靜態變數 b
	d = 130;				// 修改靜態變數的值
	cout << "d=" << d << endl;	// 輸出：d=130
}

//=============================================================================
// 主程式入口
//=============================================================================

int main() {
	//test01();	// 測試場景1：引用作為函數參數
	test02();	// 測試場景2：引用作為函數返回值

	return EXIT_SUCCESS;
}